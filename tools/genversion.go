// Copyright (c) 2012-2018 Eli Janssen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"path"
	"strings"
	"text/template"

	toml "github.com/pelletier/go-toml"
	"github.com/pelletier/go-toml/query"
)

// VersionLicenseText is a text formatter container
type VersionLicenseText struct {
	Dependencies      []map[string]string
	BTestDependencies []map[string]string
	Pkg               string
}

const tplText = `
// Copyright (c) 2012-2018 Eli Janssen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

// THIS FILE IS AUTOGENERATED. DO NOT EDIT!

package {{.Pkg}}

const licenseText = ` + "`" + `
This software is available under the MIT License at:
https://github.com/cactus/go-camo

Portions of this software utilize third party libraries:
*   Runtime dependencies:
{{range .Dependencies}}    {{if eq .last "true"}}└──{{else}}├──{{end}} {{.name}} ({{.license}} license)
{{end}}
*   Test/Build only dependencies:
{{range .BTestDependencies}}    {{if eq .last "true"}}└──{{else}}├──{{end}} {{.name}} ({{.license}} license)
{{end}}
` + "`"

func main() {
	var output, input, pkg string
	flag.StringVar(&output, "output", "", "output file")
	flag.StringVar(&input, "input", "", "input file")
	flag.StringVar(&pkg, "pkg", "", "package name")
	flag.Parse()

	if input == "" {
		log.Fatal("Input option is required")
	}

	if output == "" {
		log.Fatal("Output option is required")
	}

	if pkg == "" {
		log.Fatal("Package option is required")
	}

	fmt.Printf("Generating %s based on %s\n", path.Base(output), path.Base(input))

	t, err := template.New("fileTemplate").Parse(strings.TrimSpace(tplText))
	if err != nil {
		log.Fatal(err)
	}

	config, err := toml.LoadFile(input)
	if err != nil {
		log.Fatal(err)
	}

	dependencies := make([]map[string]string, 0)
	qc, _ := query.Compile("$.constraint[?(btestOnly)]")
	qc.SetFilter("btestOnly", func(node interface{}) bool {
		if tree, ok := node.(*toml.Tree); ok {
			return tree.Get("metadata.btest-only") != true
		}
		return false
	})
	for _, dep := range qc.Execute(config).Values() {
		if d, ok := dep.(*toml.Tree); ok {
			dependencies = append(dependencies, map[string]string{
				"name":    d.Get("name").(string),
				"license": d.GetDefault("metadata.license", "Not Specified").(string),
				"last":    "false",
			})
		}
	}
	dependencies[len(dependencies)-1]["last"] = "true"

	btestDependencies := make([]map[string]string, 0)
	qc.SetFilter("btestOnly", func(node interface{}) bool {
		if tree, ok := node.(*toml.Tree); ok {
			return tree.Get("metadata.btest-only") == true
		}
		return false
	})
	for _, dep := range qc.Execute(config).Values() {
		if d, ok := dep.(*toml.Tree); ok {
			btestDependencies = append(btestDependencies, map[string]string{
				"name":    d.Get("name").(string),
				"license": d.GetDefault("metadata.license", "Not Specified").(string),
				"last":    "false",
			})
		} else {
			fmt.Println("not a tree")
		}
	}
	btestDependencies[len(btestDependencies)-1]["last"] = "true"

	f, err := os.Create(output)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	writer := bufio.NewWriter(f)
	defer writer.Flush()

	data := &VersionLicenseText{
		Dependencies:      dependencies,
		BTestDependencies: btestDependencies,
		Pkg:               pkg,
	}

	err = t.Execute(writer, data)
	if err != nil {
		log.Fatal(err)
	}
}
